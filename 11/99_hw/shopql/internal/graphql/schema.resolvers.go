package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	"hw11_shopql/internal"
)

// Parent is the resolver for the parent field.
func (r *catalogResolver) Parent(ctx context.Context, obj *Catalog) (*Catalog, error) {
	catalog := r.Catalogs[obj.ID]
	if catalog == nil {
		return nil, fmt.Errorf("catalog not found")
	}
	parent := ModelCatalogToCatalog(catalog.Parent)
	return parent, nil
}

// Childs is the resolver for the childs field.
func (r *catalogResolver) Childs(ctx context.Context, obj *Catalog) ([]*Catalog, error) {
	catalog := r.Catalogs[obj.ID]
	if catalog == nil {
		return nil, fmt.Errorf("not found")
	}
	childs := make([]*Catalog, 0, len(catalog.Children))
	for _, child := range catalog.Children {
		childs = append(childs, ModelCatalogToCatalog(child))
	}

	return childs, nil
}

// Items is the resolver for the items field.
func (r *catalogResolver) Items(ctx context.Context, obj *Catalog, limit *int, offset *int) ([]*Item, error) {
	catalog := r.Catalogs[obj.ID]
	if catalog == nil {
		return nil, fmt.Errorf("not found")
	}
	items := make([]*Item, 0, min(len(catalog.Items), *limit))
	endIndex := min(len(catalog.Items), *offset+*limit)
	for _, item := range catalog.Items[*offset:endIndex] {
		items = append(items, ModelItemToItem(item))
	}
	return items, nil
}

// Parent is the resolver for the parent field.
func (r *itemResolver) Parent(ctx context.Context, obj *Item) (*Catalog, error) {
	item := internal.FindItemById(r.Catalogs, obj.ID)
	if item == nil {
		return nil, fmt.Errorf("not found")
	}
	return ModelCatalogToCatalog(item.Parent), nil
}

// Seller is the resolver for the seller field.
func (r *itemResolver) Seller(ctx context.Context, obj *Item) (*Seller, error) {
	item := internal.FindItemById(r.Catalogs, obj.ID)
	if item == nil {
		return nil, fmt.Errorf("item not found")
	}
	seller := r.Sellers[item.SellerId]
	if seller == nil {
		return nil, fmt.Errorf("seller not found")
	}

	return ModelSellerToSeller(seller), nil
}

// InCart is the resolver for the inCart field.
func (r *itemResolver) InCart(ctx context.Context, obj *Item) (int, error) {
	session := ctx.Value("session").(*internal.Session)
	for _, cartItem := range session.User.Cart {
		if cartItem.Item.Id == obj.ID {
			return cartItem.Count, nil
		}
	}
	return 0, nil
}

// InStockText is the resolver for the inStockText field.
func (r *itemResolver) InStockText(ctx context.Context, obj *Item) (string, error) {
	item := internal.FindItemById(r.Catalogs, obj.ID)
	if item == nil {
		return "", fmt.Errorf("item not found")
	}
	result := "хватает"
	if item.InStock <= 1 {
		result = "мало"
	} else if item.InStock > 3 {
		result = "много"
	}
	return result, nil
}

// AddToCart is the resolver for the AddToCart field.
func (r *mutationResolver) AddToCart(ctx context.Context, in *CartInput) ([]*CartItem, error) {
	session := ctx.Value("session").(*internal.Session)
	item := internal.FindItemById(r.Catalogs, in.ItemID)
	if item == nil {
		return nil, fmt.Errorf("item not found")
	}
	if item.InStock < in.Quantity {
		return nil, fmt.Errorf("not enough quantity")
	}

	userCartItem := &internal.CartItem{}
	for _, cartItem := range session.User.Cart {
		if cartItem.Item.Id == item.Id {
			userCartItem = cartItem
			break
		}
	}
	if userCartItem.Item == nil {
		userCartItem.Item = item
		session.User.Cart = append(session.User.Cart, userCartItem)
	}
	userCartItem.Count += in.Quantity
	item.InStock -= in.Quantity
	return ModelCartItemsToCartItems(session.User.Cart), nil
}

// RemoveFromCart is the resolver for the RemoveFromCart field.
func (r *mutationResolver) RemoveFromCart(ctx context.Context, in CartInput) ([]*CartItem, error) {
	session := ctx.Value("session").(*internal.Session)
	item := internal.FindItemById(r.Catalogs, in.ItemID)
	if item == nil {
		return nil, fmt.Errorf("item not found")
	}

	userCartItem := &internal.CartItem{Item: item}
	for _, cartItem := range session.User.Cart {
		if cartItem.Item.Id == item.Id {
			userCartItem = cartItem
			break
		}
	}
	userCartItem.Count -= in.Quantity
	if userCartItem.Count < 0 {
		userCartItem.Count = 0
	}
	item.InStock += in.Quantity
	return ModelCartItemsToCartItems(session.User.Cart), nil
}

// Catalog is the resolver for the Catalog field.
func (r *queryResolver) Catalog(ctx context.Context, id *string) (*Catalog, error) {
	catalog := internal.FindCatalog(r.Catalogs, *id)
	if catalog == nil {
		return nil, fmt.Errorf("not found")
	}
	return ModelCatalogToCatalog(catalog), nil
}

// Shop is the resolver for the Shop field.
func (r *queryResolver) Shop(ctx context.Context, parentID *string) ([]*Catalog, error) {
	panic(fmt.Errorf("not implemented: Shop - Shop"))
}

// Seller is the resolver for the Seller field.
func (r *queryResolver) Seller(ctx context.Context, id *string) (*Seller, error) {
	seller := internal.FindSeller(r.Sellers, *id)
	if seller == nil {
		return nil, fmt.Errorf("not found")
	}
	return ModelSellerToSeller(seller), nil
}

// MyCart is the resolver for the MyCart field.
func (r *queryResolver) MyCart(ctx context.Context) ([]*CartItem, error) {
	session := ctx.Value("session").(*internal.Session)
	return ModelCartItemsToCartItems(session.User.Cart), nil
}

// Items is the resolver for the items field.
func (r *sellerResolver) Items(ctx context.Context, obj *Seller, limit *int, offset *int) ([]*Item, error) {
	modelItems := internal.GetItemBySellerId(r.Catalogs, obj.ID, *offset, *limit)
	items := make([]*Item, 0, len(modelItems))
	for _, item := range modelItems {
		items = append(items, ModelItemToItem(item))
	}
	return items, nil
}

// Catalog returns CatalogResolver implementation.
func (r *Resolver) Catalog() CatalogResolver { return &catalogResolver{r} }

// Item returns ItemResolver implementation.
func (r *Resolver) Item() ItemResolver { return &itemResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Seller returns SellerResolver implementation.
func (r *Resolver) Seller() SellerResolver { return &sellerResolver{r} }

type catalogResolver struct{ *Resolver }
type itemResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type sellerResolver struct{ *Resolver }
